'use client'

import { useEffect, useState, useRef, useMemo } from 'react'
import { createClient } from '@/src/lib/supabase/client'
import { User } from '@supabase/supabase-js'
import { UserWithPermissions } from '@/src/lib/types/database'

// Cache global
const profileCache = new Map<string, { data: UserWithPermissions | null, timestamp: number }>()
const CACHE_DURATION = 5 * 60 * 1000
const pendingRequests = new Map<string, Promise<UserWithPermissions | null>>()
const lastLoginUpdates = new Set<string>()

// üîç CONTADOR DE INST√ÇNCIAS
let instanceCounter = 0
const instanceLocations: string[] = []

export function useAuth() {
  const [user, setUser] = useState<User | null>(null)
  const [userProfile, setUserProfile] = useState<UserWithPermissions | null>(null)
  const [loading, setLoading] = useState(true)
  
  const supabase = useMemo(() => createClient(), [])
  const isMountedRef = useRef(true)
  const initialLoadRef = useRef(false)
  
  // üîç DEBUG: Capturar stack trace para ver de onde foi chamado
  const instanceIdRef = useRef<number | null>(null)
  
  if (instanceIdRef.current === null) {
    instanceCounter++
    instanceIdRef.current = instanceCounter
    
    // Capturar stack trace
    const stack = new Error().stack
    const caller = stack?.split('\n')[2]?.trim() || 'unknown'
    instanceLocations.push(`#${instanceCounter}: ${caller}`)
    
    console.warn(`üö® Nova inst√¢ncia useAuth #${instanceCounter}`)
    console.log('üìç Chamado de:', caller)
    
    // Log todas as inst√¢ncias at√© agora
    if (instanceCounter % 5 === 0) {
      console.log(`üìä Total de inst√¢ncias useAuth: ${instanceCounter}`)
      console.table(instanceLocations)
    }
  }

  const fetchUserProfile = async (userId: string, forceRefresh = false) => {
    try {
      if (!forceRefresh) {
        const cached = profileCache.get(userId)
        if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
          console.log(`üì¶ Cache hit (inst√¢ncia #${instanceIdRef.current}):`, userId)
          return cached.data
        }
      }

      if (pendingRequests.has(userId)) {
        console.log(`‚è≥ Requisi√ß√£o em andamento (inst√¢ncia #${instanceIdRef.current}):`, userId)
        return await pendingRequests.get(userId)!
      }

      console.log(`üîç Buscando perfil (inst√¢ncia #${instanceIdRef.current}):`, userId)
      
      const fetchPromise = performActualFetch(userId)
      pendingRequests.set(userId, fetchPromise)
      
      try {
        const result = await fetchPromise
        return result
      } finally {
        pendingRequests.delete(userId)
      }
    } catch (error) {
      console.error('‚ùå Erro ao buscar perfil:', error)
      pendingRequests.delete(userId)
      return null
    }
  }

  const performActualFetch = async (userId: string) => {
    try {
      const { data, error } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('id', userId)
        .single()

      if (!error && data) {
        const profile = {
          ...data,
          permissions: data.permissions || {}
        } as UserWithPermissions
        
        profileCache.set(userId, { data: profile, timestamp: Date.now() })
        updateLastLoginOnce(userId)
        
        return profile
      }

      console.warn('‚ö†Ô∏è Criando perfil b√°sico:', error?.message)
      
      const { data: { user } } = await supabase.auth.getUser()
      if (user && user.id === userId) {
        const basicProfile: UserWithPermissions = {
          id: user.id,
          email: user.email || '',
          display_name: user.user_metadata?.full_name || user.email?.split('@')[0] || 'Usu√°rio',
          role: 'viewer' as const,
          department: null,
          avatar_url: user.user_metadata?.avatar_url || null,
          is_active: true,
          created_at: user.created_at || new Date().toISOString(),
          updated_at: new Date().toISOString(),
          created_by: user.id,
          last_login_at: new Date().toISOString(),
          permissions: {}
        }
        
        profileCache.set(userId, { data: basicProfile, timestamp: Date.now() })
        return basicProfile
      }

      return null
    } catch (error) {
      console.error('‚ùå Erro na requisi√ß√£o:', error)
      return null
    }
  }

  const updateLastLoginOnce = (userId: string) => {
    if (!lastLoginUpdates.has(userId)) {
      lastLoginUpdates.add(userId)
      
      setTimeout(async () => {
        try {
          await supabase
            .from('user_profiles')
            .update({ last_login_at: new Date().toISOString() })
            .eq('id', userId)
          console.log('‚úÖ Last login atualizado')
        } catch (error) {
          console.error('‚ùå Erro ao atualizar last_login:', error)
        }
      }, 2000)
    }
  }

  useEffect(() => {
    isMountedRef.current = true
    
    if (initialLoadRef.current) return
    initialLoadRef.current = true

    const initAuth = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser()
        
        if (!isMountedRef.current) return
        
        setUser(user)
        
        if (user) {
          const profile = await fetchUserProfile(user.id)
          if (isMountedRef.current) {
            setUserProfile(profile)
          }
        }
      } catch (error) {
        console.error('‚ùå Erro ao inicializar auth:', error)
      } finally {
        if (isMountedRef.current) {
          setLoading(false)
        }
      }
    }

    initAuth()

    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {
      console.log('üîÑ Auth state changed:', event)
      
      if (!isMountedRef.current) return

      const newUser = session?.user ?? null
      
      setUser(prevUser => {
        if (prevUser?.id === newUser?.id) return prevUser
        return newUser
      })
      
      if (newUser) {
        if (event === 'SIGNED_IN' || event === 'USER_UPDATED') {
          const profile = await fetchUserProfile(newUser.id)
          if (isMountedRef.current) {
            setUserProfile(profile)
          }
        }
      } else {
        setUserProfile(null)
        profileCache.clear()
        lastLoginUpdates.clear()
      }
    })

    return () => {
      isMountedRef.current = false
      subscription.unsubscribe()
      console.log(`üëã useAuth inst√¢ncia #${instanceIdRef.current} desmontada`)
    }
  }, [])

  const refreshProfile = async () => {
    if (user) {
      const profile = await fetchUserProfile(user.id, true)
      setUserProfile(profile)
    }
  }

  return { 
    user, 
    userProfile, 
    loading,
    refreshProfile,
    isAuthenticated: !!user,
    role: userProfile?.role || null,
    permissions: userProfile?.permissions || {}
  }
}

// üîç Fun√ß√£o helper para debug
export function debugAuthInstances() {
  console.log('üìä RESUMO DE INST√ÇNCIAS useAuth')
  console.log(`Total: ${instanceCounter} inst√¢ncias criadas`)
  console.table(instanceLocations)
}